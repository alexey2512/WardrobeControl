### WARDROBE CONTROL

У любой организации есть потребность в **гардеробе**,
а любой стандартный гардероб должен обслуживаться
**гардеробщицами**. Такая система существует на сегодняшний день
в большинстве организаций. Однако и ее можно автоматизировать.

Пусть у нас есть сущность **организация**, в организации есть
**люди** и **гардеробы**, а **гардеробщицу** мы из этой системы выведем.
Пусть у каждого человека есть свой персональный **пропуск**, в который
вшит уникальный **токен**, сгенерированный при регистрации. Гардероб же
представляет собой сущность, которая в связке с сервером умеет
идентифицировать человека по его пропуску и в зависимости от текущего
состояния в гардеробе, выполнять некоторое действие.

Будем думать о гардеробе как о множестве занумерованных крючков с
магнитными зажимами, которые расположены в порядке на некоторой
О-образной установке, способной прокручиваться в обе стороны. Вся эта
установка находится в закрытой комнате, к которой подведено окошко, а
рядом с окошком на стене висит валидатор, знающий токен этого гардероба,
умеющий считывать токен с поднесенного пропуска, посылать запросы на некий
сервер и выполнять действия, описываемые в ответах. От такого гардероба
требуется возможность прокручиваться до крючка с указанным в
ответе номером и разжимать магнит на некоторое время (чтобы клиент мог
повесить или забрать свою верхнюю одежду).

От человека требуется лишь поднести пропуск - все вычисления и механические
действия произведет гардероб в связке с сервером.

Введем ряд правил взаимодействия сущностей с сервером:
* Для регистрации новой сущности требуется контроль со стороны
  высшей по иерархии сущности (родителя). Контроль осуществляется посредством токена.
  Например, чтобы зарегистрировать новую организацию, требуется токен владельца
  проекта, а чтобы зарегистрировать новую персону, нужен токен организации;
* Для выполнения других действий над сущностью требуется контроль со стороны
  этой сущности и ее родителя;
* При удалении сущности удаляются все ее дочерние сущности транзитивно;

При выполнении запроса ```hook/action```:
* Если в гардеробе за человеком не закреплено ни одного
  крючка, то установка должна прокрутиться до ближайшего свободного
  крючка и забрать его вещи на хранение; если же в гардеробе нет
  свободных исправных крючков в данный момент, то гардероб отказывает
  клиенту в обслуживании;
* Если в гардеробе за человеком закреплен некоторый номер, то гардероб
  прокручивается до этого номера и отдает клиенту его вещи;

С более подробной документацией по API можно ознакомиться в **Swagger UI** (см. ниже)


### Локальный запуск и тестирование

Перед запуском сервера требуется сгенерировать токен владельца. Это можно 
сделать, запустив файл [App](src/main/scala/com/myapp/App.scala) с 
единственным аргументом командной строки - именем владельца (```sbt run SomeOwnerName```).
Сохраните токен в удобном для вас месте.

Для локального запуска сервера вам потребуется
[docker-compose](https://docs.docker.com/compose/).
Чтобы сервер заработал локально на вашей машине
* запустите Docker Desktop;
* выполните команду ```docker-compose up -d``` в корневом каталоге
  проекта для развертывания контейнера с базой данных;
* Запустите файл [App](src/main/scala/com/myapp/App.scala) без 
аргументов командной строки (```sbt run```);
* откройте [Swagger UI](http://localhost:8080/docs/) для тестирования API;
* Тестируйте!

Проект частично покрыт тестами. Для запуска тестов выполните ```sbt test```. 
При этом будут запущены тесты, не требующие контейнерной инфраструктуры. Это
реализуется посредством мокирования DAO. Те 
тесты, что требуют развертывания контейнера помечены ```@DoNotDiscover``` и 
находятся в пакете [database](src/test/scala/com/myapp/database). Вы можете 
запустить их по отдельности или выполнить их всех запустив файл 
[DaoImplSpec](src/test/scala/com/myapp/database/DaoImplSpec.scala).
